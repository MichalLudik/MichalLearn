using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Reflection;
using System.Runtime.CompilerServices;
using BenchmarkDotNet;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Engines;
using DotNetBenchmark;




namespace BenchmarkDotNet.Autogenerated
{
    public class Program
    {
        
        public static int Main(string[] args)
        {
            bool isDiagnoserAttached = args != null && args.Contains(BenchmarkDotNet.Engines.Engine.Signals.DiagnoserIsAttachedParam);
            var host = new ConsoleHost(Console.Out, isDiagnoserAttached);

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            if(isDiagnoserAttached)
                host.BeforeAnythingElse();

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                Type type = typeof(Program).GetTypeInfo().Assembly.GetType("BenchmarkDotNet.Autogenerated.Runnable");

                type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { host });

                return 0;
            }
            catch(Exception ex)
            {
                host.WriteLine(ex.ToString());
                return -1;
            }
        }
    }

    public class Runnable : global::DotNetBenchmark.Md5VsSha256
    {
        public static void Run(IHost host)
        {
            Runnable instance = new Runnable();
            

            host.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine("// {0}", infoLine);
            }
            var job = new Job();
            ;
            job.Freeze();
            host.WriteLine("// Job: {0}", job.DisplayInfo);
            host.WriteLine();

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                MainAction = instance.MainMultiAction,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                IdleAction = instance.IdleMultiAction,
                SetupAction = instance.setupAction,
                CleanupAction = instance.cleanupAction,
                TargetJob = job,
                OperationsPerInvoke = 1
            };

            var engine = new BenchmarkDotNet.Engines.EngineFactory().Create(engineParameters);

            engine.PreAllocate();

            instance?.setupAction();

            if (job.ResolveValue(RunMode.RunStrategyCharacteristic, EngineResolver.Instance).NeedsJitting())
                engine.Jitting(); // does first call to main action, must be executed after setup()!
            
            if(host.IsDiagnoserAttached) 
                host.AfterSetup();

            var results = engine.Run();

            if(host.IsDiagnoserAttached) 
                host.BeforeCleanup();
            instance?.cleanupAction();

            host.ReportResults(results); // printing costs memory, do this after runs
        }

        public Runnable()
        {
            setupAction = () => { };
            cleanupAction = () => { };
            idleAction = Idle;
            mainAction = Sha256;
        }

        private Action setupAction;
        private Action cleanupAction;
        private Func<System.Byte[]> idleAction;
        private Func<System.Byte[]> mainAction;

        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
            dummyVar++;
        }

        private System.Byte[] Idle()
        {
            return null;
        }

#if true

        private Consumer consumer = new Consumer();

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
                consumer.Consume(idleAction());
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
                consumer.Consume(mainAction());
            }
        }

#else

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
                idleAction();
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
                mainAction();
            }
        }

#endif
    }
}
